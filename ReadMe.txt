What is this baggotry?

LibBaggotry is a suite of utility functions which I am making available
separately from the Baggotry addon in case someone else wants them.

The central concept is the "baggish".  A baggish is a thing which can be
reasonably understood to denote a set of inventory items.  That could be:

	* True:  All items.
	* False:  No items.
	* A slotspec (as generated by Utility.Item.Slot.*()):  Those items
	* A filter:  The items picked by that filter
	* A table of { slotspec:details } pairs:  Those pairs.
	* A table of { filter:slotspec } pairs:  The union of the results
	  of using those filters on their respective slotspecs (in an
	  unspecified order)
	* A function which can be invoked on (item, slot) pairs:  The
	  results of creating a default-options filter which :includes
	  that function.

In all cases, the return should be a table of { slotspec: details } pairs,
which is, of course, still a baggish.


The next interesting concept is a "filter".  A filter is a thing which,
invoked on a slotspec, yields items which "match" the filter.  A filter
has its own default slotspec, or you can invoke it on any other slotspec.

Filter conditions are still being developed, but they include matches
of strings or numbers, and functions.  A condition can be specified in
one of three ways:
	Excludes:
		If the condition is true, the item is not included
		no matter what other conditions might apply.
	Requires:
		If the condition is false, the item is not included
		no matter what other conditions might apply.
	Includes:
		If any "includes" conditions are true, or there are
		no "includes" conditions, the item is included.

In general, you can think of the "includes" as an or-list, and the
requires as an and-list.


Filter functions:

A filter function can be registered with an optional value;
	f:includes(func, aux)
and will be invoked as
	f(details, slotspec, aux)
If aux is not provided, it will be nil.

Filters return true or false.

For diagnostic purposes (the f:dump() function), a filter should return
a one-line description of itself when invoked with details == nil.


Next big feature:  Bagground Processing (TM).  When a LibBaggotry function
needs to perform many operations, it performs one per update rather than
spamming them all at once.  If you have a cheapish video card, this should
avoid the command throttle for you!  :)


The utilities are still being worked on, but:
	Library.LibBaggotry.find(baggish)
		Finds everything, yields a { slot = details } table.
	Library.LibBaggotry.iterate(baggish, func, aux)
		Calls func(details, slot, aux) for everything in baggish,
		returns a table of the ones for which func returned a truthy
		value (not false or nil).  This is logically equivalent
		to, if baggish were a filter, doing :requires(func, aux).
	Library.LibBaggotry.reject(baggish, func, aux)
		Like iterate, but takes things for which func returns
		false/nil.
	Library.LibBaggotry.first(baggish, func, aux)
		Calls func(details, slot, aux) for things in baggish
		returning { slot: details } for the first one it finds
		for which func returned a truthy value -- note that "first"
		is not particularly deterministic.
	Library.LibBaggotry.merge(baggish, size)
		Attempts to merge everything in baggish into stacks of
		at least size, defaulting to the maximum stack size.  Smart
		enough to not try to merge things that aren't actually
		of the same type.
	Library.LibBaggotry.split(baggish, size)
		Like merge, but tries to get everything into stacks of
		exactly size, and coalesce leftovers into a single stack.

