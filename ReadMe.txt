What is this baggotry?

LibBaggotry is a suite of utility functions which I am making available
separately from the Baggotry addon in case someone else wants them.

The central concept is the "baggish".  A baggish is a thing which can be
reasonably understood to denote a set of inventory items.  That could be:

	* True:  All items.
	* False:  No items.
	* One or more slotspecs (as generated by Utility.Item.Slot.*()):
		Those items
	* A filter:  The items picked by that filter
	* A table of { slotspec:details } pairs:  Those pairs.
	* A table of { filter:slotspec } pairs:  The union of the results
	  of using those filters on their respective slotspecs (in an
	  unspecified order)
	* A function which can be invoked on (item, slot) pairs:  The
	  results of creating a default-options filter which :includes
	  that function.

In all cases, the return should be a table of { slotspec: details } pairs,
which is, of course, still a baggish.


The next interesting concept is a "filter".  A filter is a thing which,
invoked on a slotspec (or list of slotspecs), yields items which "match"
the filter.  A filter has its own default slotspec, or you can invoke it on
any other slotspec.

Filter conditions are still being developed, but they include matches
of strings or numbers, and functions.  A condition can be specified in
one of three ways:
	Excludes:
		If the condition is true, the item is not included
		no matter what other conditions might apply.
	Requires:
		If the condition is false, the item is not included
		no matter what other conditions might apply.
	Includes:
		If any "includes" conditions are true, or there are
		no "includes" conditions, the item is included.

In general, you can think of the "includes" as an or-list, and the
requires as an and-list.

Conditions are built around yet another -ish, the "matchish".  A matchish
is either a function or the name of a member of the details table (for now).
Syntax (same for excludes and requires) is:
	:includes(matchish, value)
	:includes(relop, matchish, value)

If matchish is a function, relop must be absent or '==', and the function
will be invoked as func(details, slotspec, value).  If matchish is
the name of a member of the details table, 'relop' determines the
relationship to test between the item's data and the provided value.
If you don't specify a relop, the default is '==', except for category
and name, where it is 'match'.  Relops are:
	< <= == >= > ~= match
where match only really makes sense on strings.  (As a convenience to me,
the library currently recognizes = as a synonym for ==, and != as a synonym
for ~=, but these may not survive.)

For diagnostic purposes (the f:dump() function), a filter function
should return a one-line description of itself when invoked with
details == nil.

Relational operators try to handle nil values sanely, which means that
a nil value is less than any non-nil value, and two nil values are equal
to each other.

You can create a filter using LibGetOpt, or something equivalent, using
the
	filter:from_args(table)
function; this is intended to be used with an argstring like that of
	filter:argstring()
This is the guts of the command line filter specification in LootSorter
and Baggotry; however, you can also use it to create a
SavedVariables-friendly definition of a filter, if you pass it a
similar structure.  If you don't want to mess with the getopt-type
functionality, just pass it:

	{
		leftover_args = { conditions }
	}

where conditions are a series of strings looking like:
	[+!]field:relop:value
+ means requires, ! means excludes, default is include.  So for instance:
	!stack:>:15
creates a filter which includes everything that doesn't have a stack count
of 15 or more.

Next big feature:  Bagground Processing (TM).  When a LibBaggotry function
needs to perform many operations, it performs one per update rather than
spamming them all at once.  If you have a cheapish video card, this should
avoid the command throttle for you!  :)


The utilities are still being worked on, but:
	Library.LibBaggotry.find(baggish)
		Finds everything, yields a { slot = details } table.
	Library.LibBaggotry.iterate(baggish, func, value, aux)
		Loop over baggish, doing
			value = func(details, slot, value, aux)
		and return value at the end.
	Library.LibBaggotry.select(baggish, func, aux)
		Calls func(details, slot, aux) for everything in baggish,
		returns a table of the ones for which func returned a truthy
		value (not false or nil).  This is logically equivalent
		to, if baggish were a filter, doing :requires(func, aux).
	Library.LibBaggotry.reject(baggish, func, aux)
		Like iterate, but takes things for which func returns
		false/nil.
	Library.LibBaggotry.first(baggish, func, aux)
		Calls func(details, slot, aux) for things in baggish
		returning { slot: details } for the first one it finds
		for which func returned a truthy value -- note that "first"
		is not particularly deterministic.
	Library.LibBaggotry.merge(baggish, size)
		Attempts to merge everything in baggish into stacks of
		at least size, defaulting to the maximum stack size.  Smart
		enough to not try to merge things that aren't actually
		of the same type.
	Library.LibBaggotry.split(baggish, size)
		Like merge, but tries to get everything into stacks of
		exactly size, and coalesce leftovers into a single stack.
	Library.LibBaggotry.slotspec_p(slotspec)
		Returns true if 'slotspec' is a valid slotspec.  As a
		bonus feature, if slotspec is of the form
			char_identifier:slotspec
		yields slotspec, charspec (two values) so you can do
		fancy things like look in other inventories.
	Library.LibBaggotry.rarity_p(rarity, permissive)
		Returns a non-nil/false value if 'rarity' is a valid rarity
		In fact, returns three values in such cases;
			quality, name, { r, g, b }
		The quality is a value starting at 1 for trash and
		increasing monotonically, the name is a canonicalized name,
		and 'permissive' controls whether rarity_p tries to
		translate non-standard names such as 'purple' or 'white'.
		(The returned name is canonicalized.)  Ordering is:
			trash
			common
			uncommon
			rare
			epic
			relic
			quest
	Library.LibBaggotry.queue(func, args)
		Appends func to the Bagground Processing (SM) queue.
		Items registered this way are processed, one per frame,
		in the order they were queued.  The argument list is
		stored and passed in when the function is invoked.
	Library.LibBaggotry.char_identifier(character, faction, shard)	
		yields "Shard/faction/Character", using provided values or
		the current shard, faction, or character.
	Library.LibBaggotry.char_identifier_p(string)
		Determines whether string looks to be a valid char_identifier.
		Returns nil or shard, faction, charname.
	Library.LibBaggotry.rarity_color(rarity)
		returns r, g, b
	Library.LibBaggotry.merge_items(baggish)
		Returns a merged list in which stacks of the same item
		are combined, with _charspec, _slotspec, etc. updated
		suitably.  Keys will be item type, rather than slots.
	Library.LibBaggotry.move_items(baggish, slotspec, replace_items)
		Move items from baggish into slots described by slotspec.
		If replace_items is truthy, will swap items into places that
		contain items not matching baggish.
		(If baggish is a filter, this is defined by filter.match,
		if baggish is a list of items, it'd be items that are in
		baggish.)
		Note that bags themselves (sibg, sbbg) are filtered out
		from both ends of this.
