What is this baggotry?

LibBaggotry is a suite of utility functions which I am making available
separately from the Baggotry addon in case someone else wants them.

The central concept is the "baggish".  A baggish is a thing which can be
reasonably understood to denote a set of inventory items.  That could be:

	* True:  All items.
	* False:  No items.
	* A slotspec (as generated by Utility.Item.Slot.*()):  Those items
	* A filter:  The items picked by that filter
	* A table of { slotspec:details } pairs:  Those pairs.
	* A table of { filter:slotspec } pairs:  The union of the results
	  of using those filters on their respective slotspecs (in an
	  unspecified order)
	* A function which can be invoked on (item, slot) pairs:  The
	  results of creating a default-options filter which :includes
	  that function.

In all cases, the return should be a table of { slotspec: details } pairs,
which is, of course, still a baggish.


The next interesting concept is a "filter".  A filter is a thing which,
invoked on a slotspec, yields items which "match" the filter.  A filter
has its own default slotspec, or you can invoke it on any other slotspec.

Filter conditions are still being developed, but they include matches
of strings or numbers, and functions.  A condition can be specified in
one of three ways:
	Excludes:
		If the condition is true, the item is not included
		no matter what other conditions might apply.
	Requires:
		If the condition is false, the item is not included
		no matter what other conditions might apply.
	Includes:
		If any "includes" conditions are true, or there are
		no "includes" conditions, the item is included.

In general, you can think of the "includes" as an or-list, and the
requires as an and-list.

Conditions are built around yet another -ish, the "matchish".  A matchish
is either a function or the name of a member of the details table (for now).
Syntax (same for excludes and requires) is:
	:includes(matchish, value)
	:includes(relop, matchish, value)

If matchish is a function, relop must be absent or '==', and the function
will be invoked as func(details, slotspec, value).  If matchish is
the name of a member of the details table, 'relop' determines the
relationship to test between the item's data and the provided value.
If you don't specify a relop, the default is '==', except for category
and name, where it is 'match'.  Relops are:
	< <= == >= > ~= match
where match only really makes sense on strings.  (As a convenience to me,
the library currently recognizes = as a synonym for ==, and != as a synonym
for ~=, but these may not survive.)

For diagnostic purposes (the f:dump() function), a filter function
should return a one-line description of itself when invoked with
details == nil.

Relational operators try to handle nil values sanely, which means that
a nil value is less than any non-nil value, and two nil values are equal
to each other.

Next big feature:  Bagground Processing (TM).  When a LibBaggotry function
needs to perform many operations, it performs one per update rather than
spamming them all at once.  If you have a cheapish video card, this should
avoid the command throttle for you!  :)


The utilities are still being worked on, but:
	Library.LibBaggotry.find(baggish)
		Finds everything, yields a { slot = details } table.
	Library.LibBaggotry.iterate(baggish, func, value, aux)
		Loop over baggish, doing
			value = func(details, slot, value, aux)
		and return value at the end.
	Library.LibBaggotry.select(baggish, func, aux)
		Calls func(details, slot, aux) for everything in baggish,
		returns a table of the ones for which func returned a truthy
		value (not false or nil).  This is logically equivalent
		to, if baggish were a filter, doing :requires(func, aux).
	Library.LibBaggotry.reject(baggish, func, aux)
		Like iterate, but takes things for which func returns
		false/nil.
	Library.LibBaggotry.first(baggish, func, aux)
		Calls func(details, slot, aux) for things in baggish
		returning { slot: details } for the first one it finds
		for which func returned a truthy value -- note that "first"
		is not particularly deterministic.
	Library.LibBaggotry.merge(baggish, size)
		Attempts to merge everything in baggish into stacks of
		at least size, defaulting to the maximum stack size.  Smart
		enough to not try to merge things that aren't actually
		of the same type.
	Library.LibBaggotry.split(baggish, size)
		Like merge, but tries to get everything into stacks of
		exactly size, and coalesce leftovers into a single stack.
	Library.LibBaggotry.slotspec_p(slotspec)
		Returns true if 'slotspec' is a valid slotspec
	Library.LibBaggotry.rarity_p(rarity)
		Returns a non-nil value if 'rarity' is a valid rarity (one
		of 'trash', 'common', 'uncommon', 'rare', 'epic', or 'relic')
		Non-nil values are 1 for trash and increase with quality.
